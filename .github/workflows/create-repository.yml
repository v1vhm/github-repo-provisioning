# Inputs:
#   port_payload: Port JSON payload
#   mock: When true, skip side-effecting steps (default: false)
# Port payload keys used (see docs/port-payload-contracts.md):
# - runId
# - blueprint
# - requestedBy
# - properties.port_product_identifier
# - properties.port_service_identifier
# - properties.port_service_name
# - properties.port_service_description
# - properties.port_cost_centre
# - properties.port_owning_team
# - properties.port_owning_team_identifier
# - properties.port_repo_visibility
# - properties.port_owning_team_slug
# - properties.port_owner_team_permission
# - properties.cookiecutter_template
# - properties.cookiecutter_user_context
name: Create repository from template

on:
  workflow_dispatch:
    inputs:
      port_payload:
        description: 'Port JSON payload'
        required: true
        type: string
      mock:
        description: 'Run in mock mode, skipping side effects'
        required: false
        type: boolean
        default: false

permissions:
  contents: write
  id-token: write
  actions: read

env:
  GH_ORG: ${{ secrets.GH_ORG }}

jobs:
  create:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Parse payload
        id: parse
        run: |
          PAYLOAD='${{ inputs.port_payload }}'
          echo "$PAYLOAD" | jq -e '.runId,
            .properties.port_product_identifier,
            .properties.port_service_identifier,
            .properties.port_service_name,
            .properties.port_service_description,
            .properties.port_cost_centre,
            .properties.port_owning_team,
            .properties.port_owning_team_identifier,
            .properties.port_repo_visibility,
            .properties.port_owning_team_slug,
            .properties.port_owner_team_permission,
            .properties.cookiecutter_template,
            .properties.cookiecutter_user_context' >/dev/null

          PORT_CONTEXT=$(echo "$PAYLOAD" | jq -c '.properties | with_entries(select(.key | startswith("port_")))')
          USER_CONTEXT=$(echo "$PAYLOAD" | jq -c .properties.cookiecutter_user_context)
          COMBINED_CONTEXT=$(jq -c -n --argjson port "$PORT_CONTEXT" --argjson user "$USER_CONTEXT" '$port + $user')
          {
            echo "RUN_ID=$(echo "$PAYLOAD" | jq -r .runId)"
            echo "BLUEPRINT=$(echo "$PAYLOAD" | jq -r .blueprint)"
            echo "REQUESTED_BY=$(echo "$PAYLOAD" | jq -r .requestedBy)"
            echo "REPO_NAME=$(echo "$PAYLOAD" | jq -r .properties.port_service_identifier)"
            echo "DESCRIPTION=$(echo "$PAYLOAD" | jq -r .properties.port_service_description)"
            echo "REPO_VISIBILITY=$(echo "$PAYLOAD" | jq -r .properties.port_repo_visibility)"
            echo "OWNING_TEAM_SLUG=$(echo "$PAYLOAD" | jq -r .properties.port_owning_team_slug)"
            echo "OWNER_TEAM_PERMISSION=$(echo "$PAYLOAD" | jq -r .properties.port_owner_team_permission)"
            echo "COOKIECUTTER_TEMPLATE=$(echo "$PAYLOAD" | jq -r .properties.cookiecutter_template)"
            echo "COOKIECUTTER_CONTEXT=$COMBINED_CONTEXT"
            echo "PRODUCT_IDENTIFIER=$(echo "$PAYLOAD" | jq -r .properties.port_product_identifier)"
            echo "PRODUCT_COST_CENTRE=$(echo "$PAYLOAD" | jq -r .properties.port_cost_centre)"
            echo "CREATED_AT=$(date -u +%Y-%m-%dT%H:%M:%SZ)"
          } >> "$GITHUB_ENV"

      - name: Mock run notice
        if: ${{ inputs.mock }}
        run: |
          echo "Mock run: skipping side-effecting steps"

      - name: Get GitHub App token
        id: app-token
        uses: ./.github/actions/get-gh-app-token
        with:
          app_id: ${{ secrets.GH_APP_ID }}
          private_key: ${{ secrets.GH_APP_PRIVATE_KEY }}
          owner: ${{ secrets.GH_ORG }}

      - name: Get bot user ID
        id: get-user-id
        env:
          GH_TOKEN: ${{ steps.app-token.outputs.token }}
        run: echo "user-id=$(gh api "/users/${{ steps.app-token.outputs.app-slug }}[bot]" --jq .id)" >> "$GITHUB_OUTPUT"

      - name: Configure git user
        run: |
          git config --global user.name '${{ steps.app-token.outputs.app-slug }}[bot]'
          git config --global user.email '${{ steps.get-user-id.outputs.user-id }}+${{ steps.app-token.outputs.app-slug }}[bot]@users.noreply.github.com'

      - name: Validate repository name
        run: ./scripts/validate-name.sh "$GH_ORG" "$REPO_NAME"

      - name: Draft manifest
        run: |
          mkdir -p repositories/manifests
          context_lines=$(echo "$COOKIECUTTER_CONTEXT" | jq -r 'to_entries[] | "      \(.key): \"\(.value)\""')
          cat > "repositories/manifests/${REPO_NAME}.yaml" <<MANIFEST
          apiVersion: v1
          kind: GitHubRepository
          metadata:
            name: $REPO_NAME
            createdAt: "$CREATED_AT"
            createdBy: "$REQUESTED_BY"
          spec:
            description: "$DESCRIPTION"
            visibility: "$REPO_VISIBILITY"
            ownerTeam:
              slug: "$OWNING_TEAM_SLUG"
              permission: "$OWNER_TEAM_PERMISSION"
            template:
              source: "$COOKIECUTTER_TEMPLATE"
              context:
          ${context_lines}
          status:
            phase: creating
          MANIFEST
                    echo "MANIFEST=repositories/manifests/${REPO_NAME}.yaml" >> "$GITHUB_ENV"

      - name: Azure login
        if: ${{ !inputs.mock }}
        uses: azure/login@v2
        with:
          client-id: ${{ secrets.AZURE_CLIENT_ID }}
          tenant-id: ${{ secrets.AZURE_TENANT_ID }}
          subscription-id: ${{ secrets.AZURE_SUBSCRIPTION_ID }}

      - name: Setup Terraform
        if: ${{ !inputs.mock }}
        uses: hashicorp/setup-terraform@v3

      - name: Terraform init
        if: ${{ !inputs.mock }}
        working-directory: repositories/modules/repo
        env:
          GITHUB_TOKEN: ${{ env.GITHUB_TOKEN }}
          ARM_USE_OIDC: true
          ARM_CLIENT_ID: ${{ secrets.AZURE_CLIENT_ID }}
          ARM_TENANT_ID: ${{ secrets.AZURE_TENANT_ID }}
          ARM_SUBSCRIPTION_ID: ${{ secrets.AZURE_SUBSCRIPTION_ID }}
        run: |
          terraform init \
            -backend-config="resource_group_name=${{ secrets.AZURE_RESOURCE_GROUP }}" \
            -backend-config="storage_account_name=${{ secrets.AZURE_STORAGE_ACCOUNT }}" \
            -backend-config="container_name=${{ secrets.AZURE_STORAGE_CONTAINER }}" \
            -backend-config="key=repos/${REPO_NAME}.tfstate" \
            -backend-config="use_azuread_auth=true"

      - name: Terraform apply
        if: ${{ !inputs.mock }}
        working-directory: repositories/modules/repo
        env:
          GITHUB_TOKEN: ${{ env.GITHUB_TOKEN }}
          ARM_USE_OIDC: true
          ARM_CLIENT_ID: ${{ secrets.AZURE_CLIENT_ID }}
          ARM_TENANT_ID: ${{ secrets.AZURE_TENANT_ID }}
          ARM_SUBSCRIPTION_ID: ${{ secrets.AZURE_SUBSCRIPTION_ID }}
        run: |
          terraform apply -auto-approve \
            -var "org=$GH_ORG" \
            -var "repo_name=$REPO_NAME" \
            -var "description=$DESCRIPTION" \
            -var "visibility=$REPO_VISIBILITY" \
            -var "owner_team_slug=$OWNING_TEAM_SLUG" \
            -var "owner_perm=$OWNER_TEAM_PERMISSION"
          terraform output -json > tf.json
          {
            echo "repo_id=$(jq -r .repo_id.value tf.json)"
            echo "html_url=$(jq -r .html_url.value tf.json)"
            echo "ssh_url=$(jq -r .ssh_url.value tf.json)"
            echo "repo_created=true"
          } >> "$GITHUB_ENV"

      - name: Cleanup Terraform
        if: ${{ always() && !inputs.mock }}
        working-directory: repositories/modules/repo
        run: rm -rf .terraform terraform.tfstate*

      - name: Scaffold repository
        if: ${{ !inputs.mock }}
        env:
          GITHUB_TOKEN: ${{ env.GITHUB_TOKEN }}
        run: |
          pip install cookiecutter
          tmpdir=$(mktemp -d)
          context_args=$(echo "$COOKIECUTTER_CONTEXT" | jq -r 'to_entries | map("\(.key)=\(.value|@sh)") | join(" ")')
          eval set -- "$context_args"
          cookiecutter "$COOKIECUTTER_TEMPLATE" --no-input --output-dir "$tmpdir" "$@"
          generated_dir=$(ls -d "$tmpdir"/*)
          cd "$generated_dir"
          git init
          git remote add origin "https://x-access-token:${GITHUB_TOKEN}@github.com/${GH_ORG}/${REPO_NAME}.git"
          git add .
          git commit -m "Initial commit from template"
          git branch -M main
          git push origin main

      - name: Configure repository
        if: ${{ !inputs.mock }}
        env:
          GITHUB_TOKEN: ${{ env.GITHUB_TOKEN }}
          GH_SECRETS: ${{ toJson(secrets) }}
        run: |
          set -euo pipefail
          git clone "$COOKIECUTTER_TEMPLATE" template-repo
          mkdir tf-config
          yq -o=json template-repo/.provisioning/repository-config.yml > tf-config/config.json
          # Build a map of secret names to values. Each item in the config's
          # `secrets` array specifies a `ref` pointing either to a workflow
          # secret (`source: workflow_secret`) or an environment variable
          # (`source: env`).
          jq --argjson s "$GH_SECRETS" '
            [.secrets // [] | .[] | select(.source != "none") |
              {key: .name,
               value: (if .source == "workflow_secret"
                       then $s[.ref]         # look up workflow secret
                       else env[.ref]        # read env var by name
                      end)}] | from_entries
          ' tf-config/config.json > tf-config/secret-values.json
          cat > tf-config/main.tf <<'TF'
          terraform {
            required_providers {
              github = {
                source  = "integrations/github"
                version = "~> 6.0"
              }
            }
          }

          provider "github" {
            owner = var.owner
          }

          module "initial_config" {
            source        = "../modules/github-initial-config"
            owner         = var.owner
            repo          = var.repo
            config        = jsondecode(file("${path.module}/config.json"))
            secret_values = jsondecode(file("${path.module}/secret-values.json"))
          }

          variable "owner" { type = string }
          variable "repo"  { type = string }
          TF
          cd tf-config
          terraform init
          terraform apply -auto-approve -var owner="${GH_ORG}" -var repo="${REPO_NAME}"

      - name: Cleanup Terraform (configuration)
        if: ${{ always() && !inputs.mock }}
        run: rm -rf tf-config/.terraform tf-config/terraform.tfstate*

      - name: Mock run notice (configuration)
        if: ${{ inputs.mock }}
        run: |
          echo "Mock run: skipping repository configuration"

      - name: Finalize manifest
        if: ${{ !inputs.mock }}
        run: |
          context_lines=$(echo "$COOKIECUTTER_CONTEXT" | jq -r 'to_entries[] | "      \(.key): \"\(.value)\""')
          cat > "$MANIFEST" <<MANIFEST
          apiVersion: v1
          kind: GitHubRepository
          metadata:
            name: $REPO_NAME
            createdAt: "$CREATED_AT"
            createdBy: "$REQUESTED_BY"
          spec:
            description: "$DESCRIPTION"
            visibility: "$REPO_VISIBILITY"
            ownerTeam:
              slug: "$OWNING_TEAM_SLUG"
              permission: "$OWNER_TEAM_PERMISSION"
            template:
              source: "$COOKIECUTTER_TEMPLATE"
              context:
          $context_lines
          status:
            id: "$repo_id"
            htmlUrl: "$html_url"
            sshUrl: "$ssh_url"
            phase: active
          MANIFEST

      - name: Commit manifest
        if: ${{ !inputs.mock }}
        uses: ./.github/actions/commit-yaml
        with:
          path: ${{ env.MANIFEST }}
          message: Add repository '${{ env.REPO_NAME }}' (automated via Port)

      - name: Report failure to Port
        if: ${{ failure() && !inputs.mock }}
        uses: port-labs/port-github-action@v1
        with:
          clientId: ${{ secrets.PORT_CLIENT_ID }}
          clientSecret: ${{ secrets.PORT_CLIENT_SECRET }}
          operation: PATCH_RUN
          runId: ${{ env.RUN_ID }}
          status: failure
          logMessage: 'Workflow failed'

      - name: Mark manifest failed
        if: ${{ failure() && !inputs.mock }}
        run: |
          if [ -f "$MANIFEST" ]; then
            sed -i 's/phase: creating/phase: failed/' "$MANIFEST"
          fi
