# Port GitHub Automation – Repository Update and Future Plan

## Updated Repository Documentation

### Project Overview and Goals

This repository automates the creation and management of GitHub repositories, teams, and other resources in a GitHub organization, driven by events from **Port** (an internal developer portal). The automation follows a **GitOps** style: every change is represented as a YAML manifest in the repo and applied via code, ensuring an auditable history of all org changes. Workflows are triggered by Port (via `workflow_dispatch` with a JSON payload) and run using GitHub Actions to provision resources (mostly via Terraform) and then update both this repo’s manifests and Port’s catalog to reflect the new state.

### Repository Structure and State Management

The repository is organized by resource type for clarity:

* **`repositories/`** – Contains Terraform module code for GitHub repositories and a `manifests/` subdirectory for repository YAML manifests (one `<repo>.yaml` per GitHub repo).
* **`teams/`** – Contains Terraform module code for GitHub teams and a `manifests/` subdirectory for team YAML manifests.
* **`environments/`** – Placeholder for environment configurations (not yet fully implemented).
* **`.github/workflows/`** – GitHub Actions workflow files, one per operation (create repo, update team, add team to repo, etc.).
* **`.github/actions/`** – Reusable composite actions for common tasks (e.g. committing YAML changes).
* **`modules/github-initial-config/`** – Terraform module used to apply initial settings to new repositories.

**Terraform State:** Each resource uses a separate Terraform state file (remote on Azure Blob Storage) for isolation. The Azure backend is accessed via OIDC, using secrets like `AZURE_STORAGE_ACCOUNT`, `AZURE_STORAGE_CONTAINER`, etc., with state file keys namespaced per entity (e.g. `repos/<repo>.tfstate` for each repository). This segmentation keeps state files small and avoids lock conflicts when multiple workflows run concurrently.

Repository templates also carry a `.provisioning/repository-config.yml` file describing branch rulesets, default labels, team access, Actions variables and secrets. During repository creation a temporary Terraform workspace consumes this file through the `github-initial-config` module to configure the repository. The state from this step lives only on disk and is deleted after apply, leaving no persistent state for these settings.

**GitHub App Authentication:** Workflows use a GitHub App’s credentials (APP ID, installation ID, private key in secrets) to obtain an installation token with appropriate org permissions. Every workflow uses the `actions/create-github-app-token@v1` action to mint a token, stored as `GITHUB_TOKEN` for subsequent API calls and Terraform operations. (Future improvement: create a reusable action to handle this token generation across workflows to reduce repetition.)

### Workflow Patterns and Conventions

All workflows follow a standardized **6-step pattern** for consistency:

1. **Parse Input:** The workflow is triggered via `workflow_dispatch` with a JSON `port_payload`. The workflow parses this JSON (using `jq` or GitHub expressions) to extract needed inputs such as entity name, settings, Port run ID, blueprint ID, etc. Each workflow defines a similar `on: workflow_dispatch` with an input `port_payload` and begins by extracting required fields (name, description, etc.) into environment variables for easy reference.

2. **Validation:** Before making changes, the workflow performs validations. Examples: check that a requested repository or team name is valid and not already in use, verify a parent team exists when specified, ensure inputs like visibility or privacy are within allowed values, etc. If a pre-condition fails, the workflow exits early and reports a failure status to Port (with a helpful message).

3. **Draft Manifest:** The workflow creates or updates a YAML manifest file representing the desired state of the resource **before** applying changes. For create operations, an initial YAML file is constructed with the basic info (name, requested settings, etc.) and a status of “creating”. Update workflows load the existing manifest to merge changes. This manifest uses a custom schema with `apiVersion`, `kind`, `metadata`, `spec`, and `status` sections, capturing all relevant information about the resource. It is saved under the appropriate `manifests/` directory but not yet committed at this stage.

4. **Provisioning (Terraform & API):** The actual creation/update is performed. Whenever possible, **Terraform** is used to manage resources via the official GitHub provider. Each workflow invokes `terraform init` and `terraform apply` in the corresponding module directory (e.g., `repositories/modules/repo` or `teams/modules/team`), passing inputs as Terraform variables. Terraform ensures idempotent creation/updating of resources (repos, teams, memberships, etc.) and captures outputs like generated IDs or URLs. Any resource aspects not covered by Terraform are handled with targeted API calls or `gh` CLI usage within the workflow. For example, repository content initialization uses Cookiecutter: after Terraform creates a repo, the workflow installs Cookiecutter and runs it to scaffold the repo from a template, then pushes an initial commit via git. Similarly, adding or removing a team’s access to a repo uses the GitHub REST API (via `gh api`) because fine-grained permission adjustments aren’t exposed in Terraform’s provider. This combined approach leverages Terraform for stateful management and the GitHub API for any gaps.

   *Notable pattern:* **Repository Archival** is managed through Terraform by toggling the `archived` attribute of the `github_repository` resource. Earlier designs considered using a direct API call for archiving, but using Terraform ensures the archived status is tracked in state and avoids drift. (An *unarchive* workflow can be similarly implemented by setting `archived=false` – this was noted as a future improvement.)

5. **Update Port Catalog:** After successful provisioning, the workflow updates Port’s catalog via the official Port GitHub Action. We use **`port-labs/port-github-action@v1`** to upsert or modify the relevant entity in Port. This action is configured with the Port OAuth client ID/secret and allows us to specify the operation (UPSERT or DELETE), the target blueprint (e.g., repository or team blueprint), the entity identifier and title, its properties, relations, and the Port run ID and status. Using Port’s provided action replaced the initial idea of writing a custom HTTP call for Port’s API – this standardized approach reduced custom code and improved reliability. In complex cases, multiple Port updates are done: e.g., removing a team from a repo triggers an UPSERT for the repository’s Port entity (to update its list of teams) and, if configured to mirror, an UPSERT for the team’s Port entity (to update its list of repos). All Port updates use the run ID to tie into the originating Port action run, and on workflow failure we call the action with `PATCH_RUN` to mark the run as failed.

6. **Finalize YAML and Commit:** The YAML manifest drafted earlier is now finalized with actual data from the provisioning step (for create/update) – e.g., resource IDs, URLs, timestamps, and status set to “active” (or “archived” as appropriate). The workflow then commits the YAML file(s) to the repository. We standardized this commit process with a reusable composite action **`commit-yaml`**. This action stages the specified file(s), creates a commit with a templated message (e.g., “Add repository ‘<name>’ (automated via Port)” or “Update team ‘<slug>’…”), and pushes to the `main` branch. Using a composite for commits ensures every workflow follows the same Git commit procedure, and it encapsulates the git operations in one place. (All workflows operate on the default branch with bot credentials — no PRs — consistent with the trunk-based approach.) If a workflow modifies multiple manifests (e.g., removing a team affects a repo manifest and optionally a team manifest), all changes are committed in a single atomic commit. In the rare case of commit conflicts (e.g., concurrent runs), our logic will retry pushing or fail with a clear error; this is noted as an area for further improvement (ensuring idempotent or retriable commits).

Finally, if any step fails at any point, a failure status is reported back to Port (using the Port action with `operation: PATCH_RUN` and `status: failure`) and the error is surfaced in the workflow logs. Workflows also attempt to clean up partial changes on failure – for example, marking a manifest’s phase as “failed” if provisioning did not complete.

### Key Implemented Workflows

By following the above pattern, the repository includes the following workflows (all in `.github/workflows/`):

* **Create Repository** (`create-repository.yml`): Creates a new GitHub repository from a template. Uses Terraform to create the repo (with settings like visibility, description, and an initial team permission), then runs Cookiecutter to populate it. A subsequent **Configure repository** block reads the template’s `.provisioning/repository-config.yml` and applies it with the `github-initial-config` module to set rulesets, labels, team access, variables and secrets. The transient Terraform state for this configuration is cleaned up at the end. Commits a new `repositories/manifests/<name>.yaml` with the repo’s details and upserts the Port *Repository* entity. Has validation to prevent duplicate names and ensure naming conventions.

* **Update Repository** (`update-repository.yml`): Updates settings of an existing repository (description, visibility, homepage URL, topics, default branch, etc.). It loads the current state from the YAML, merges in changes from the Port payload, and applies Terraform to update those fields. It explicitly does **not** manage team memberships (to avoid overwriting changes managed by other workflows). After updating, it commits changes to the manifest (including a `lastUpdatedAt` timestamp) and upserts the Port entity with new properties.

* **Archive Repository** (`archive-repository.yml`): Archives a repository (read-only state) via Terraform by setting `archived=true` on the repo resource. It first confirms the repo exists and isn’t already archived, then runs a targeted Terraform plan/apply to flip the flag. The manifest is updated to mark the repo as archived (and an `archivedAt` timestamp is added), and the Port entity is updated with `"archived": true` in its properties. (Unarchiving would be similar but is not yet implemented – see Future Plan.)

* **Create Team** (`create-team.yml`): Creates a new GitHub team via Terraform. Accepts team name, description, privacy (closed or secret), optional parent team, and initial members. Validates name/slug uniqueness and that the parent team exists if provided. Before applying Terraform, it filters the member list: any usernames not in the org or with invalid roles are skipped (with a warning). Terraform then creates the team and adds specified members. The team manifest `teams/manifests/<slug>.yaml` is created, listing members and aliases (alternate slugs) if any, and the Port *Team* entity is upserted with team details including members and aliases. Non-org members are simply omitted but reported, rather than failing the run.

* **Update Team** (`update-team.yml`): Updates an existing team’s settings or membership. This workflow supports a `members_mode` input to choose how to handle the membership list. In **`set`** mode, it treats the provided list as the complete desired roster and uses Terraform to reconcile (adding missing members and removing extras) – effectively ensuring the team’s membership matches exactly. In **`add`** mode, it only adds new users from the input list (keeping existing ones intact). In **`remove`** mode, it only removes users in the input list. The add/remove modes are handled with custom logic using the GitHub API for incremental changes, since Terraform alone cannot express partial membership changes easily. Like team creation, it skips unknown users and invalid roles gracefully. All changes update the YAML manifest and Port entity. The team’s description, privacy, parent team, and aliases can also be updated. The manifest’s `lastUpdatedAt` is set on any change. This workflow illustrates the flexible patterns introduced in later development to handle idempotency and partial updates safely.

* **Add Team to Repo** (`add-team-to-repo.yml`): Grants a team access to a repository or upgrades their permission. Because the Terraform provider doesn’t support non-destructive updates to team permissions on a repo (and to avoid state collisions), this uses the GitHub API via `gh` CLI. It ensures the repository exists and is not archived (guardrail: it will fail early if the repo is archived to prevent modifying an inactive repo). It then adds the team with the specified permission, or if the team already has lower access, upgrades it (but never downgrades any existing permission). After the API call, it updates the repository’s YAML manifest: in the `teams:` list of that repo, either adds or updates the entry for that team with the new permission and a timestamp. Optionally, if `mirror_on_team_manifest` is true, it also updates the team’s manifest to include the repo in the team’s `repositories:` list (this dual-sourcing is off by default, with the single source of truth being the repository manifest). The changes are committed and the Port repository entity is upserted to include the team relation. (If mirrored, the Port team entity is also upserted to include the repository relation, keeping Port’s data consistent).

* **Remove Team from Repo** (`remove-team-from-repo.yml`): Revokes a team’s access from a repository. This workflow also uses the GitHub API to remove the team’s permission (since Terraform would require stateful management tying the team to the repo). It checks that both the repo and team exist, and that the repo is not archived (you cannot change permissions on an archived repo). It then attempts to delete the team’s access; if the team already had no access, the workflow is essentially a no-op but still succeeds gracefully (idempotent removal). After removal, the repo’s manifest is updated by removing that team from its `teams` list (with a `lastUpdatedAt` timestamp). If `mirror_on_team_manifest:true`, the team’s manifest is also updated to drop the repo from its list. Both the repo and team Port entities are then upserted to reflect the changed relationship (removing the link between that repo and team in Port). The manifest update and commit process again uses the standard commit action.

* **Delete Team** (`delete-team.yml`): Completely removes a team from GitHub. This is orchestrated carefully to handle all related state: it first checks if the team exists and if it has any repositories associated. If repos are found and a `force` flag isn’t true, it will log a warning (in practice, teams with lingering repo access can still be deleted, as archiving or removing access is handled separately). It then performs a Terraform destroy on the team’s Terraform state to remove it from the org (the team Terraform module was designed to allow destroying by slug, using an empty config). After Terraform confirms deletion, it double-checks via GitHub API that the team is gone. Next, it cleans up manifests: the team’s own YAML file is deleted, and every repository manifest is scanned to remove references to that team (this is done via a short Python script looping through `repositories/manifests/*.yaml`). Any changed repo manifests are staged. We then commit the manifest changes (removing the team file and updating repos) in one commit using the commit-yaml action. Finally, the workflow calls the Port action with `operation: DELETE` for the team’s Port entity, and also updates any affected Port repository entities (via a follow-up job that iterates through changed repos) to remove the team from their relations. This deletion workflow demonstrates the **end-to-end cleanup** of state: Terraform state, GitHub actual state, this GitOps repo manifests, and Port catalog are all kept in sync when a team is removed. It also shows advanced use of the Port action for deleting an entity and updating related entities.

**Security and Permissions:** All workflows run with minimal necessary permissions on the GitHub token. We use the GitHub App installation token (with org admin scope) for most operations. The `contents: write` permission is needed to push commits back to this repo. The `id-token: write` permission is used to authenticate to Azure for Terraform state (via OIDC). We also ensure that secrets (like Azure and Port credentials) are properly passed to actions and not exposed in logs.

**Tooling and linting:** Throughout development, we adopted **`actionlint`** to ensure workflows are free of syntax errors or bad practices. All workflows have been run through actionlint and adjusted accordingly (for example, updating the Azure login action to v2 for compatibility, fixing indentation or quoting issues in YAML, etc.). Contributors are expected to run actionlint on any modified workflows as a pre-commit or CI step to maintain quality. Additionally, shell scripts include `set -euo pipefail` for rigor, and many steps use `jq` with `-e` to validate JSON structure. These patterns help catch errors early and make the automation robust.

### Port Integration Norms

Integration with Port is a first-class aspect of this system. Each workflow treats Port as both the trigger source and the destination for reporting results. Key conventions include:

* **Blueprint-driven logic:** The Port payload includes a `blueprint` identifier (representing the Port **Blueprint** that triggered the action). Workflows use this to know which blueprint to upsert. For repository-related actions, this might be something like `"githubRepository"`; for teams, `"githubTeam"`, etc. In create/update workflows, the blueprint from the payload is used directly in the Port action calls. In cross-cutting workflows (like adding/removing team relations), we ensure to update both sides appropriately – e.g., use the repository’s blueprint (from payload) when updating the repo entity, and the known team blueprint for the team entity. Blueprint names are **not hardcoded in multiple places**; wherever possible, they are passed through from the trigger to avoid drift. (One noted improvement is to centralize blueprint name definitions or pass them more explicitly to avoid any hardcoding at all.)

* **Entity Identifiers:** We use consistent identifiers for Port entities. For GitHub Repositories, the repo name (or full name) serves as the unique identifier in Port. For Teams, the team slug is used as the identifier. These are included in the Port action inputs (`identifier` and `title` fields) so that Port knows which entity to upsert or delete.

* **Properties and Relations:** The Port action payload is constructed to mirror the YAML manifest contents. For example, repository properties sent to Port include description, visibility, URLs, and the archived flag. Team properties include description, privacy, and member lists (and we pass arrays as JSON for properties like members or aliases). Relations are used to link entities in Port’s catalog: e.g., a repository entity might have a relation to its owner team, and a team entity might relate to the repositories it owns. When those relations change, the workflows update them via the Port action’s `relations` field (passing JSON). For instance, removing a team from a repo will update the repo’s Port entity `teams` relation list, and if mirroring, update the team’s `repositories` relation list. This keeps Port’s model in sync with reality.

* **Run Reporting:** Every workflow uses the Port action to mark the run status. On success, we include `status: success` along with an optional `logMessage` that can provide a summary or any warnings (e.g., “Skipped members: user1 user2” in case some team members were not added). On any failure, `status: failure` is sent so that Port’s UI or orchestration knows the action did not complete, and we include a brief error message. This integration means the platform (Port) always gets feedback on what happened, and it can present details to the user who triggered the action.

### Summary of Evolved Practices

Over the course of implementing these workflows, several important patterns emerged and early assumptions were refined:

* **Use of Vendor Actions:** We initially considered implementing custom actions (for interacting with Port’s API, cookiecutter, etc.), but evolved to use vendor-provided actions when available for reliability and maintainability. Notably, we use the official **Port GitHub Action** for all Port API interactions instead of a custom curl/script solution, and we considered using Port’s Cookiecutter action but ultimately implemented the templating step inline for flexibility.

* **Reusable Components:** We factored out common steps. The **`commit-yaml` composite action** now standardizes the commit & push process for manifest files across workflows. This prevents inconsistencies in how changes are recorded and allows easy updates to commit behavior in one place. We also use shared scripts (in `scripts/`) for input validation (e.g., naming conventions) to avoid duplicating logic. Further refactoring is planned to DRY things up even more (for example, a shared action for obtaining the GitHub App token, as mentioned above, and a shared script for cleaning up manifests on deletion to replace the duplicated inline Python).

* **Strict Linting and Validation:** Early on, some workflows had minor issues (YAML syntax, action versions) that were caught by `actionlint`. We enforced running actionlint on every workflow update, which led to fixes like upgrading to `azure/login@v2` for OIDC and consistent quoting/formatting. This standardization improved cross-workflow consistency (e.g., all workflows now request the same permissions set and follow similar step naming conventions).

* **Terraform for Full Lifecycle:** We embraced Terraform not just for creation but for updates and deletions where possible. For example, archiving a repository was handled via Terraform state (ensuring the archived status is tracked and can be unarchived in state) rather than an ad-hoc API call. Deleting a team is done with `terraform destroy` to leverage the state knowledge (ensuring even if the team wasn’t fully applied, state cleanup happens). This approach of using Terraform for the entire lifecycle (create, update, archive, delete) where feasible keeps the infrastructure-as-code single source of truth, with API calls reserved for those changes Terraform can’t handle (like fine-grained relationship edits).

* **Immutable Logs and Git History:** By committing all changes to the `main` branch immediately, we maintain a chronological history of org changes in git. Each commit is tagged in the message as automated via Port, making it clear which changes were human vs. automation. There are no long-lived feature branches; everything merges to trunk, which reflects the current desired state of the GitHub org. This was a conscious design (trunk-based GitOps) to favor simplicity and traceability.

The repository’s README has been updated with these practices, listing all required **secrets and config** (GitHub App keys, Azure backend IDs, Port credentials, etc.) and pointing to this documentation for details. New contributors or AI agents can refer to the README for setup, and use the **Agents Guide** (below) for understanding design conventions.

---

## Refined Plan – Next Steps and Improvements

Having completed the initial implementation tasks (all workflows for create/update of repos and teams, relation management, archiving, deletion, etc., as detailed above), we performed a review and refinement (Task 13 in the original plan). The system is functional and aligns with its original goals. However, to further improve consistency, reusability, and maintainability, we propose the following new tasks as a refreshed plan for future development:

1. **Implement “Unarchive Repository” Workflow:** *Add a counterpart to the archive workflow to restore an archived repository to active status.* This would be similar to the archive process but setting `archived=false`. We can reuse the repository Terraform module for this (since it tracks the `archived` attribute). The workflow should validate the repo is archived (skip if not), then run Terraform to unarchive. Update the manifest (remove or mark the archived flag, update timestamps) and update Port (set `"archived": false` and status back to active). This ensures a complete lifecycle for repository states is supported.

2. **Reusable GitHub App Token Action:** *Removed.* The composite action `.github/actions/get-gh-app-token` was dropped; workflows now generate tokens directly with `actions/create-github-app-token@v1`.

3. **Centralize Manifest Update Logic:** *Completed.* The script `scripts/manifest-utils.py` provides helpers for manifest mutations and has replaced ad‑hoc Python in team↔repo workflows.

4. **Blueprint Configuration and Hardening:** *Ensure Port blueprint identifiers are consistently managed.* While our workflows use the blueprint from the Port payload for the primary entity, in some cases we used literal blueprint keys (e.g., `githubTeam` in the remove-team or delete-team workflows for updating team relations). Introduce a centralized mapping or constants (perhaps in a JSON file or as repository environment variables) for blueprint names like “GitHub Repository” and “GitHub Team”. This way, if Port’s blueprint IDs ever change or if we want to integrate with a different Port environment, we can update blueprint names in one spot. At minimum, clearly document the expected blueprint keys and ensure all workflows either receive them as inputs or derive them from one source. This task improves the portability and clarity of Port integration.

5. **Complete Environment Workflows:** *Implement the placeholder “Add Environment” (and possibly “Delete Environment”) workflows.* Our structure includes an `environments/` directory and we reserved a task for adding an environment to a repository (likely representing something like creating a deployment environment in GitHub with certain protection rules). We should finalize the design for how Port triggers environment creation (what inputs are needed, e.g., repo name, env name, secrets or protection settings), and then implement `.github/workflows/add-environment.yml`. This would involve possibly calling GitHub APIs (since GitHub Environments can be managed via API) or Terraform if supported in the provider. Ensure it follows the same 6-step pattern: validate input, update manifest (e.g., adding an `environments:` section in the repo’s YAML), create the environment in GitHub (API), commit the manifest, and update Port (most likely an Environment blueprint). Similarly, if environment removal is needed, a workflow can remove an environment from a repo and update records. This extends the automation coverage to another resource type in line with our repository design.

6. **Enhance Testing & CI:** *In progress.* Baseline checks (`actionlint`,
   [`tflint`](https://github.com/terraform-linters/tflint), and
   `terraform validate`) now run in CI and sample payloads exist for
   [`act`](https://github.com/nektos/act) (including `--dryrun` mock runs).
   Further work can expand automated testing across all workflows and
   improve mocking of external services.

7. **Documentation and Onboarding Improvements:** *Continuously update documentation for end-users and contributors.* Now that the system has evolved, ensure the primary README clearly reflects how to use the workflows (for example, how Port should be configured to trigger them, any sample payloads, etc.), and that the developer docs (like this file and the Agents guide) are kept in sync. Adding diagrams or an overview of the relationships between Port, this repo, and GitHub might be helpful for new stakeholders. We should also document the composite actions (like `commit-yaml`) usage and inputs for anyone who might reuse or modify them.

Each of these tasks will make the automation more robust and easier to manage. They should be tackled after reviewing the current system to avoid breaking any existing functionality. With these improvements, the repository will become even more consistent: less duplicated logic, easier configuration management, and support for the full lifecycle of resources.

By addressing the above, we continue the evolutionary approach of this project – iteratively refining the automation with lessons learned. Future agents or developers taking on these tasks should read the updated Agents Guide below for context and guidelines to ensure new changes align with established patterns.
