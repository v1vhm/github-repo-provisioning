# Inputs:
#   port_payload: Port JSON payload
#   mock: When true, skip side-effecting steps (default: false)
# Port payload keys used (see docs/port-payload-contracts.md):
# - runId
# - blueprint
# - requestedBy
# - properties.team_slug
# - properties.force
# - properties.note
name: Delete GitHub team

on:
  workflow_dispatch:
    inputs:
      port_payload:
        description: "Port JSON payload"
        required: true
        type: string
      mock:
        description: "Run in mock mode, skipping side effects"
        required: false
        type: boolean
        default: false

permissions:
  contents: write
  actions: read
  id-token: write

env:
  GH_ORG: ${{ github.repository_owner }}

jobs:
  delete:
    runs-on: ubuntu-latest
    outputs:
      repos: ${{ steps.manifests.outputs.repos }}
      run_id: ${{ env.RUN_ID }}
      port_message: ${{ env.PORT_MESSAGE }}
    steps:
      - name: Create GitHub App token
        id: app-token
        uses: actions/create-github-app-token@v2
        with:
          app-id: ${{ secrets.GH_APP_ID }}
          private-key: ${{ secrets.GH_APP_PRIVATE_KEY }}
          owner: ${{ env.GH_ORG }}
      - name: Export token
        run: |
          echo "GITHUB_TOKEN=${{ steps.app-token.outputs.token }}" >> "$GITHUB_ENV"
          echo "GH_TOKEN=${{ steps.app-token.outputs.token }}" >> "$GITHUB_ENV"
      - name: Configure git user
        env:
          GH_TOKEN: ${{ steps.app-token.outputs.token }}
        run: |
          user_id=$(gh api "/users/${{ steps.app-token.outputs.app-slug }}[bot]" --jq .id)
          git config --global user.name '${{ steps.app-token.outputs.app-slug }}[bot]'
          git config --global user.email "${user_id}+${{ steps.app-token.outputs.app-slug }}[bot]@users.noreply.github.com"
      - name: Configure git remote
        run: |
          if [ -d .git ]; then
            git remote set-url origin "https://x-access-token:${{ steps.app-token.outputs.token }}@github.com/${GITHUB_REPOSITORY}.git"
          fi

      - name: Checkout
        uses: actions/checkout@v4
        with:
          fetch-depth: 0
          token: ${{ steps.app-token.outputs.token }}

      - name: Parse payload
        run: |
          set -euo pipefail
          PAYLOAD='${{ inputs.port_payload }}'
          echo "$PAYLOAD" | jq -e '.runId,.blueprint,.properties.team_slug' >/dev/null
          RUN_ID=$(echo "$PAYLOAD" | jq -r .runId)
          BLUEPRINT=$(echo "$PAYLOAD" | jq -r .blueprint)
          REQUESTED_BY=$(echo "$PAYLOAD" | jq -r .requestedBy)
          TEAM_SLUG=$(echo "$PAYLOAD" | jq -r .properties.team_slug | tr '[:upper:]' '[:lower:]' | xargs)
          FORCE=$(echo "$PAYLOAD" | jq -r '.properties.force // false')
          NOTE=$(echo "$PAYLOAD" | jq -r '.properties.note // ""')
          if [[ -z "$TEAM_SLUG" ]]; then echo "team_slug required" >&2; exit 1; fi
          NOW=$(date -u +%Y-%m-%dT%H:%M:%SZ)
          {
            echo "RUN_ID=$RUN_ID"
            echo "BLUEPRINT=$BLUEPRINT"
            echo "REQUESTED_BY=$REQUESTED_BY"
            echo "TEAM_SLUG=$TEAM_SLUG"
            echo "FORCE=$FORCE"
            echo "NOTE=$NOTE"
            echo "NOW=$NOW"
          } >> "$GITHUB_ENV"

      - name: Mock run notice
        if: ${{ inputs.mock }}
        run: |
          echo "Mock run: skipping side-effecting steps"

      - name: Azure login
        if: ${{ !inputs.mock }}
        uses: azure/login@v2
        with:
          client-id: ${{ secrets.AZURE_CLIENT_ID }}
          tenant-id: ${{ secrets.AZURE_TENANT_ID }}
          subscription-id: ${{ secrets.AZURE_SUBSCRIPTION_ID }}

      - name: Setup Terraform
        if: ${{ !inputs.mock }}
        uses: hashicorp/setup-terraform@v3

      - name: Discover existence
        run: |
          set -euo pipefail
          TEAM_NAME=""
          if gh api "orgs/${GH_ORG}/teams/${TEAM_SLUG}" >/tmp/team.json 2>/tmp/team.err; then
            TEAM_EXISTS=true
            TEAM_NAME=$(jq -r .name /tmp/team.json)
            repos=$(gh api --paginate "/orgs/${GH_ORG}/teams/${TEAM_SLUG}/repos" -q '.[].name') || true
            if [[ -n "$repos" && "$FORCE" != "true" ]]; then
              echo "Warning: team has repo access: $repos" >&2
            fi
          else
            if grep -q 'Not Found' /tmp/team.err; then
              TEAM_EXISTS=false
            else
              cat /tmp/team.err >&2; exit 1
            fi
          fi
          state=$(az storage blob exists --account-name "${{ secrets.AZURE_STORAGE_ACCOUNT }}" --container-name "${{ secrets.AZURE_STORAGE_CONTAINER }}" --name "teams/${TEAM_SLUG}.tfstate" --auth-mode login -o tsv --query exists)
          if [[ "$TEAM_EXISTS" != "true" && "$state" != "true" ]]; then
            MODE=no-op
          else
            MODE=destroy
          fi
          {
            [ -n "$TEAM_NAME" ] && echo "TEAM_NAME=$TEAM_NAME"
            echo "TEAM_EXISTS=$TEAM_EXISTS"
            echo "STATE_EXISTS=$state"
            echo "MODE=$MODE"
          } >> "$GITHUB_ENV"

      - name: Terraform destroy
        if: ${{ !inputs.mock && env.MODE == 'destroy' }}
        working-directory: teams/modules/team
        env:
          GITHUB_TOKEN: ${{ env.GITHUB_TOKEN }}
          ARM_USE_OIDC: true
          ARM_CLIENT_ID: ${{ secrets.AZURE_CLIENT_ID }}
          ARM_TENANT_ID: ${{ secrets.AZURE_TENANT_ID }}
          ARM_SUBSCRIPTION_ID: ${{ secrets.AZURE_SUBSCRIPTION_ID }}
        run: |
          set -euo pipefail
          terraform init \
            -backend-config="resource_group_name=${{ secrets.AZURE_RESOURCE_GROUP }}" \
            -backend-config="storage_account_name=${{ secrets.AZURE_STORAGE_ACCOUNT }}" \
            -backend-config="container_name=${{ secrets.AZURE_STORAGE_CONTAINER }}" \
            -backend-config="key=teams/${TEAM_SLUG}.tfstate" \
            -backend-config="use_azuread_auth=true"
          NAME=${TEAM_NAME:-$TEAM_SLUG}
          for i in 1 2; do
            if terraform destroy -auto-approve \
              -var "org=$GH_ORG" \
              -var "team_slug=$TEAM_SLUG" \
              -var "team_name=$NAME" \
              -var "privacy=closed" \
              -var "description=" \
              -var "parent_team_slug="; then
              break
            fi
            if [ "$i" -eq 2 ]; then exit 1; fi
            sleep 5
          done

      - name: Cleanup Terraform
        if: ${{ always() && !inputs.mock && env.MODE == 'destroy' }}
        working-directory: teams/modules/team
        run: rm -rf .terraform terraform.tfstate*

      - name: Verify deletion
        if: ${{ !inputs.mock && env.MODE == 'destroy' }}
        run: |
          set -e
          if gh api "orgs/${GH_ORG}/teams/${TEAM_SLUG}" >/dev/null 2>&1; then
            echo "Team still exists after destroy" >&2; exit 1; fi

      - name: Set Port message
        run: |
          if [ "$MODE" = "no-op" ]; then
            msg="no-op (team already absent)"
          else
            msg="team deleted via Terraform"
          fi
          if [ -n "$NOTE" ]; then msg="$msg - $NOTE"; fi
          echo "PORT_MESSAGE=$msg" >> "$GITHUB_ENV"

      - name: Clean manifests
        if: ${{ !inputs.mock }}
        id: manifests
        run: |
          set -euo pipefail
          pip install pyyaml >/dev/null
          slug="$TEAM_SLUG"
          removed=false
          if [ -f "teams/manifests/${slug}.yaml" ]; then
            git rm -f "teams/manifests/${slug}.yaml"
            removed=true
          fi
          python <<'PY' > repo_updates.json
          import os, yaml, json, glob
          slug=os.environ['TEAM_SLUG']; ts=os.environ['NOW']
          changed=[]
          updates=[]
          for path in glob.glob('repositories/manifests/*.yaml'):
              with open(path) as f:
                  data=yaml.safe_load(f) or {}
              teams=data.get('teams',[])
              new=[t for t in teams if t.get('slug')!=slug]
              if new!=teams:
                  data['teams']=new
                  status=data.setdefault('status',{})
                  status['lastUpdatedAt']=ts
                  with open(path,'w') as f: yaml.safe_dump(data,f,sort_keys=False)
                  changed.append(path)
                  updates.append({'name':os.path.splitext(os.path.basename(path))[0],'teams':[t.get('slug') for t in new]})
          print(json.dumps({'changed':changed,'updates':updates}))
          PY
          jq -r '.changed[]' repo_updates.json | while read -r p; do git add "$p"; done
          echo "repos=$(jq -c '.updates' repo_updates.json)" >> "$GITHUB_OUTPUT"
          echo "team_removed=$removed" >> "$GITHUB_OUTPUT"

      - name: Determine commit path
        if: ${{ !inputs.mock }}
        run: |
          path="repositories/manifests"
          if [ "${{ steps.manifests.outputs.repos }}" = "[]" ]; then
            path="teams/manifests"
          fi
          echo "COMMIT_PATH=$path" >> "$GITHUB_ENV"

      - name: Build commit message
        if: ${{ !inputs.mock }}
        run: |
          msg="Delete team '${TEAM_SLUG}' via Terraform (Port)"
          if [ -n "$NOTE" ]; then msg="$msg - $NOTE"; fi
          echo "COMMIT_MSG=$msg" >> "$GITHUB_ENV"

      - name: Commit manifests
        if: ${{ !inputs.mock }}
        uses: ./.github/actions/commit-yaml
        with:
          path: ${{ env.COMMIT_PATH }}
          message: ${{ env.COMMIT_MSG }}

      - name: Delete team in Port
        if: ${{ !inputs.mock }}
        uses: port-labs/port-github-action@v1
        with:
          clientId: ${{ secrets.PORT_CLIENT_ID }}
          clientSecret: ${{ secrets.PORT_CLIENT_SECRET }}
          operation: DELETE
          blueprint: ${{ env.BLUEPRINT }}
          identifier: ${{ env.TEAM_SLUG }}
          runId: ${{ env.RUN_ID }}
          status: success
          logMessage: ${{ env.PORT_MESSAGE }}

      - name: Report failure to Port
        if: ${{ failure() && !inputs.mock }}
        uses: port-labs/port-github-action@v1
        with:
          clientId: ${{ secrets.PORT_CLIENT_ID }}
          clientSecret: ${{ secrets.PORT_CLIENT_SECRET }}
          operation: PATCH_RUN
          runId: ${{ env.RUN_ID }}
          status: failure
          logMessage: 'Workflow failed'

  update-port-repos:
    needs: delete
    if: ${{ !inputs.mock && needs.delete.outputs.repos != '[]' }}
    runs-on: ubuntu-latest
    strategy:
      matrix:
        repo: ${{ fromJson(needs.delete.outputs.repos) }}
    steps:
      - name: Update repository in Port
        uses: port-labs/port-github-action@v1
        with:
          clientId: ${{ secrets.PORT_CLIENT_ID }}
          clientSecret: ${{ secrets.PORT_CLIENT_SECRET }}
          operation: UPSERT
          identifier: ${{ matrix.repo.name }}
          title: ${{ matrix.repo.name }}
          blueprint: githubRepository
          relations: |
            { "teams": ${{ toJson(matrix.repo.teams) }} }
          runId: ${{ needs.delete.outputs.run_id }}
          status: success
          logMessage: ${{ needs.delete.outputs.port_message }}

# Tests:
# - Happy path: existing team with repo access -> destroyed, manifests removed.
# - No-op: team absent -> manifests scrubbed, Port success.
# - Backend lock: transient error on destroy retries then succeeds.
# - Destroy failure: terraform destroy fails -> Port failure, manifests untouched.
# - Commit collision: concurrent commit requires retry.
