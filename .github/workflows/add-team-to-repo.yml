# Inputs:
#   port_payload: Port JSON payload
#   mock: When true, skip side-effecting steps (default: false)
# Port payload keys used (see docs/port-payload-contracts.md):
# - runId
# - blueprint
# - requestedBy
# - properties.repo_name
# - properties.team_slug
# - properties.permission
# - properties.mirror_on_team_manifest
# - properties.note
name: Grant team access to repository

on:
  workflow_dispatch:
    inputs:
      port_payload:
        description: "Port JSON payload"
        required: true
        type: string
      mock:
        description: "Run in mock mode, skipping side effects"
        required: false
        type: boolean
        default: false

permissions:
  contents: write
  actions: read
  id-token: write

env:
  GH_ORG: ${{ github.repository_owner }}

jobs:
  add:
    runs-on: ubuntu-latest
    steps:
      - name: Create GitHub App token
        id: app-token
        uses: actions/create-github-app-token@v2
        with:
          app-id: ${{ secrets.GH_APP_ID }}
          private-key: ${{ secrets.GH_APP_PRIVATE_KEY }}
          owner: ${{ env.GH_ORG }}
      - name: Export token
        run: |
          echo "GITHUB_TOKEN=${{ steps.app-token.outputs.token }}" >> "$GITHUB_ENV"
          echo "GH_TOKEN=${{ steps.app-token.outputs.token }}" >> "$GITHUB_ENV"
      - name: Configure git user
        env:
          GH_TOKEN: ${{ steps.app-token.outputs.token }}
        run: |
          user_id=$(gh api "/users/${{ steps.app-token.outputs.app-slug }}[bot]" --jq .id)
          git config --global user.name '${{ steps.app-token.outputs.app-slug }}[bot]'
          git config --global user.email "${user_id}+${{ steps.app-token.outputs.app-slug }}[bot]@users.noreply.github.com"
      - name: Configure git remote
        run: |
          if [ -d .git ]; then
            git remote set-url origin "https://x-access-token:${{ steps.app-token.outputs.token }}@github.com/${GITHUB_REPOSITORY}.git"
          fi

      - name: Checkout
        uses: actions/checkout@v4
        with:
          fetch-depth: 0
          token: ${{ steps.app-token.outputs.token }}

      - name: Parse payload
        run: |
          set -euo pipefail
          PAYLOAD='${{ inputs.port_payload }}'
          echo "$PAYLOAD" | jq -e '.runId,.blueprint,.properties.repo_name,.properties.team_slug,.properties.permission' >/dev/null
          RUN_ID=$(echo "$PAYLOAD" | jq -r .runId)
          BLUEPRINT=$(echo "$PAYLOAD" | jq -r .blueprint)
          REQUESTED_BY=$(echo "$PAYLOAD" | jq -r .requestedBy)
          REPO_NAME=$(echo "$PAYLOAD" | jq -r .properties.repo_name | xargs)
          TEAM_SLUG=$(echo "$PAYLOAD" | jq -r .properties.team_slug | tr '[:upper:]' '[:lower:]' | xargs)
          PERMISSION=$(echo "$PAYLOAD" | jq -r .properties.permission | xargs)
          case "$PERMISSION" in pull|triage|push|maintain|admin) ;; *) echo "Invalid permission: $PERMISSION" >&2; exit 1;; esac
          MIRROR=$(echo "$PAYLOAD" | jq -r '.properties.mirror_on_team_manifest // false')
          if [[ "$MIRROR" != "true" && "$MIRROR" != "false" ]]; then
            echo "mirror_on_team_manifest must be boolean" >&2; exit 1
          fi
          NOTE=$(echo "$PAYLOAD" | jq -r '.properties.note // ""')
          NOW=$(date -u +%Y-%m-%dT%H:%M:%SZ)
          {
            echo "RUN_ID=$RUN_ID"
            echo "BLUEPRINT=$BLUEPRINT"
            echo "REQUESTED_BY=$REQUESTED_BY"
            echo "REPO_NAME=$REPO_NAME"
            echo "TEAM_SLUG=$TEAM_SLUG"
            echo "PERMISSION=$PERMISSION"
            echo "MIRROR=$MIRROR"
            echo "NOTE=$NOTE"
            echo "NOW=$NOW"
          } >> "$GITHUB_ENV"

      - name: Mock run notice
        if: ${{ inputs.mock }}
        run: |
          echo "Mock run: skipping side-effecting steps"

      - name: Validate repository and team
        run: |
          set -euo pipefail
          repo_resp=$(gh api "repos/${GH_ORG}/${REPO_NAME}" 2>/tmp/repo_err) || { cat /tmp/repo_err >&2; exit 1; }
          if [ "$(echo "$repo_resp" | jq -r .archived)" = "true" ]; then
            echo "Repository ${REPO_NAME} is archived" >&2; exit 1; fi
          gh api "orgs/${GH_ORG}/teams/${TEAM_SLUG}" >/dev/null 2>&1 || { echo "Team ${TEAM_SLUG} not found" >&2; exit 1; }
            current=$(gh api "repos/${GH_ORG}/${REPO_NAME}/teams" -q ".[] | select(.slug==\"${TEAM_SLUG}\") | .permission" || true)
          ranks='{ "pull":1, "triage":2, "push":3, "maintain":4, "admin":5 }'
          req_rank=$(echo "$ranks" | jq -r ".[\"$PERMISSION\"]")
          cur_rank=$(echo "$ranks" | jq -r ".[\"$current\"] // 0")
          action="create"
          if [ -n "$current" ]; then
            if [ "$cur_rank" -ge "$req_rank" ]; then
              action="noop"
            else
              action="upgrade"
            fi
          fi
            {
              echo "CURRENT_PERMISSION=$current"
              echo "ACTION=$action"
            } >> "$GITHUB_ENV"

      - name: Apply permission
        if: ${{ !inputs.mock && env.ACTION != 'noop' }}
        run: |
          for i in 1 2; do
            if gh api --method PUT "/orgs/${GH_ORG}/teams/${TEAM_SLUG}/repos/${GH_ORG}/${REPO_NAME}" -f permission="${PERMISSION}"; then
              break
            elif [ "$i" -eq 2 ]; then
              exit 1
            else
              sleep 5
            fi
            done

      - name: Verify permission
        if: ${{ !inputs.mock }}
        run: |
            final=$(gh api "repos/${GH_ORG}/${REPO_NAME}/teams" -q ".[] | select(.slug==\"${TEAM_SLUG}\") | .permission" || true)
            if [ -z "$final" ]; then
              echo "Failed to read final permission" >&2; exit 1; fi
            case "$ACTION" in
              create) msg="granted ${PERMISSION}";;
              upgrade) msg="upgraded to ${PERMISSION}";;
              noop) msg="no-op (current $final)";;
            esac
            {
              echo "FINAL_PERMISSION=$final"
              echo "PORT_MESSAGE=$msg"
            } >> "$GITHUB_ENV"

      - name: Build commit message
        if: ${{ !inputs.mock }}
        run: |
          msg="Grant team '${TEAM_SLUG}' '${FINAL_PERMISSION}' on repo '${REPO_NAME}' (via Port)"
          if [ -n "$NOTE" ]; then
            msg="$msg - $NOTE"
          fi
          echo "COMMIT_MESSAGE=$msg" >> "$GITHUB_ENV"

      - name: Update manifests
        if: ${{ !inputs.mock }}
        run: |
          set -euo pipefail
          pip install pyyaml >/dev/null
          python - <<'PY' >> "$GITHUB_ENV"
          import os, json, yaml, importlib.util
          spec = importlib.util.spec_from_file_location('mu', 'scripts/manifest-utils.py')
          mu = importlib.util.module_from_spec(spec); spec.loader.exec_module(mu)
          repo=os.environ['REPO_NAME']; slug=os.environ['TEAM_SLUG']; perm=os.environ['FINAL_PERMISSION']; ts=os.environ['NOW']
          repo_path=f"repositories/manifests/{repo}.yaml"
          repo_changed = mu.upsert_repo_team(repo_path, slug, perm, ts)
          if repo_changed:
              mu.touch_last_updated(repo_path, ts)
          with open(repo_path) as f: data=yaml.safe_load(f) or {}
          print(f"REPO_MANIFEST={repo_path}")
          print("TEAM_LIST="+json.dumps([t['slug'] for t in data.get('teams', [])], separators=(',',':')))
          print(f"REPO_CHANGED={'1' if repo_changed else '0'}")
          if os.environ.get('MIRROR') == 'true':
              team=os.environ['TEAM_SLUG']; repo=os.environ['REPO_NAME']
              team_path=f"teams/manifests/{team}.yaml"
              team_changed = mu.upsert_team_repo(team_path, repo, perm, ts)
              if team_changed:
                  mu.touch_last_updated(team_path, ts)
              with open(team_path) as f: tdata=yaml.safe_load(f) or {}
              print(f"TEAM_MANIFEST={team_path}")
              print(f"TEAM_CHANGED={'1' if team_changed else '0'}")
          PY

      - name: Upsert entity to Port
        if: ${{ !inputs.mock }}
        uses: port-labs/port-github-action@v1
        with:
          clientId: ${{ secrets.PORT_CLIENT_ID }}
          clientSecret: ${{ secrets.PORT_CLIENT_SECRET }}
          operation: UPSERT
          identifier: ${{ env.REPO_NAME }}
          title: ${{ env.REPO_NAME }}
          blueprint: ${{ env.BLUEPRINT }}
          relations: |
            { "teams": ${{ env.TEAM_LIST }} }
          runId: ${{ env.RUN_ID }}
          status: success
          logMessage: ${{ env.PORT_MESSAGE }}

      - name: Stage team manifest
        if: ${{ !inputs.mock && env.MIRROR == 'true' && env.TEAM_CHANGED == '1' }}
        run: git add "${{ env.TEAM_MANIFEST }}"

      - name: Commit manifest(s)
        if: ${{ !inputs.mock }}
        uses: ./.github/actions/commit-yaml
        with:
          path: ${{ env.REPO_MANIFEST }}
          message: ${{ env.COMMIT_MESSAGE }}

      - name: Report failure to Port
        if: ${{ failure() && !inputs.mock }}
        uses: port-labs/port-github-action@v1
        with:
          clientId: ${{ secrets.PORT_CLIENT_ID }}
          clientSecret: ${{ secrets.PORT_CLIENT_SECRET }}
          operation: PATCH_RUN
          runId: ${{ env.RUN_ID }}
          status: failure
          logMessage: 'Workflow failed'

# Tests:
# - Happy path (new grant): team had no access -> now maintain.
# - Upgrade: team had push -> request admin -> upgraded.
# - No-op: team already maintain -> request maintain -> success/no-op.
# - Repo missing: fails fast; Port failure reported.
# - Team missing: fails fast; Port failure reported.
# - Archived repo: fails with explicit message.
# - Mirror disabled/enabled: verify manifests updated accordingly.
